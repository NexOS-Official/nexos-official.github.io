
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ghost AI Assistant ðŸ‘»</title>
<script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
<script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>
<style>
  * {
    box-sizing: border-box;
  }

  body {
    background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    overflow: hidden;
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
  }

  /* Ghost is now the main interactive element, centered on screen */
  .ghost-container {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 32px;
    z-index: 1;
  }

  .ghost {
    position: relative;
    width: 240px;
    height: 300px;
    animation: bob 2.8s ease-in-out infinite;
    transform-origin: center center;
    transition: filter 0.5s ease;
  }

  /* Ghost glows based on state */
  .ghost.listening {
    filter: drop-shadow(0 0 60px rgba(16, 185, 129, 0.8));
    animation: bob 2.8s ease-in-out infinite, ghostPulse 2s ease-in-out infinite;
  }

  .ghost.speaking {
    filter: drop-shadow(0 0 80px rgba(139, 92, 246, 0.9));
    animation: bob 2.8s ease-in-out infinite, ghostPulse 0.8s ease-in-out infinite;
  }

  .ghost.thinking {
    filter: drop-shadow(0 0 60px rgba(59, 130, 246, 0.8));
    animation: bob 2.8s ease-in-out infinite, ghostPulse 1.5s ease-in-out infinite;
  }

  .ghost.idle {
    filter: drop-shadow(0 0 40px rgba(180, 150, 255, 0.6));
  }

  @keyframes bob {
    0%, 100% { transform: translateY(0) scaleY(1); }
    50% { transform: translateY(-12px) scaleY(1.08); }
  }

  @keyframes ghostPulse {
    0%, 100% { transform: translateY(0) scale(1); }
    50% { transform: translateY(-8px) scale(1.05); }
  }

  .ghost-body {
    position: absolute;
    width: 100%;
    height: 100%;
    clip-path: path("M230.809 115.385V249.411C230.809 269.923 214.985 287.282 194.495 288.411C184.544 288.949 175.364 285.718 168.26 280C159.746 273.154 147.769 273.461 139.178 280.23C132.638 285.384 124.381 288.462 115.379 288.462C106.377 288.462 98.1451 285.384 91.6055 280.23C82.912 273.385 70.9353 273.385 62.2415 280.23C55.7532 285.334 47.598 288.411 38.7246 288.462C17.4132 288.615 0 270.667 0 249.359V115.385C0 51.6667 51.6756 0 115.404 0C179.134 0 230.809 51.6667 230.809 115.385Z");
    overflow: hidden;
  }

  .gradient {
    position: absolute;
    inset: 0;
    background: radial-gradient(circle at 30% 30%, #FFB3D9, transparent 60%),
                radial-gradient(circle at 70% 70%, #87CEEB, transparent 60%),
                radial-gradient(circle at 40% 80%, #4A90E2, transparent 70%),
                radial-gradient(circle at 80% 40%, #2C3E50, transparent 60%),
                radial-gradient(circle at 50% 50%, #B980FF, transparent 80%);
    background-blend-mode: screen;
    filter: brightness(1.25) saturate(1.4) contrast(1.2) blur(10px);
    animation: meshFlow 6s ease-in-out infinite alternate;
  }

  @keyframes meshFlow {
    0% {
      background-position: 30% 30%, 70% 70%, 40% 80%, 80% 40%, 50% 50%;
    }
    100% {
      background-position: 60% 40%, 40% 60%, 70% 30%, 30% 70%, 50% 50%;
    }
  }

  .eye {
    position: absolute;
    width: 40px;
    height: 60px;
    background: #0a0a0a;
    border-radius: 50%;
    top: 120px;
    transform: translate(-50%, -50%);
    animation: blink 3s infinite ease-in-out;
    z-index: 2;
  }

  .eye.left { left: 80px; }
  .eye.right { left: 150px; }

  @keyframes blink {
    0%, 90%, 100% { transform: translate(-50%, -50%) scaleY(1); }
    95% { transform: translate(-50%, -50%) scaleY(0.1); }
  }

  /* Status icon overlays on ghost */
  .status-icon {
    position: absolute;
    bottom: -20px;
    left: 50%;
    transform: translateX(-50%);
    width: 64px;
    height: 64px;
    border-radius: 50%;
    background: rgba(10, 10, 10, 0.8);
    border: 3px solid rgba(99, 102, 241, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
    color: rgba(99, 102, 241, 0.9);
    backdrop-filter: blur(10px);
    transition: all 0.4s ease;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
  }

  .ghost.listening .status-icon {
    border-color: rgba(16, 185, 129, 0.8);
    color: #10B981;
    background: rgba(16, 185, 129, 0.15);
    animation: iconPulse 2s ease-in-out infinite;
  }

  .ghost.speaking .status-icon {
    border-color: rgba(139, 92, 246, 0.8);
    color: #8B5CF6;
    background: rgba(139, 92, 246, 0.15);
    animation: iconPulse 0.8s ease-in-out infinite;
  }

  .ghost.thinking .status-icon {
    border-color: rgba(59, 130, 246, 0.8);
    color: #3B82F6;
    background: rgba(59, 130, 246, 0.15);
    animation: iconPulse 1.5s ease-in-out infinite;
  }

  @keyframes iconPulse {
    0%, 100% { transform: translateX(-50%) scale(1); }
    50% { transform: translateX(-50%) scale(1.1); }
  }

  /* Status text below ghost */
  .status-text {
    text-align: center;
    color: rgba(255, 255, 255, 0.95);
    font-size: 20px;
    font-weight: 600;
    letter-spacing: 0.3px;
    margin-top: 8px;
  }

  .status-subtitle {
    font-size: 14px;
    color: rgba(255, 255, 255, 0.5);
    margin-top: 6px;
    font-weight: 400;
  }

  /* Minimal bottom controls */
  .calling-ui {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(180deg, rgba(10,10,10,0) 0%, rgba(10,10,10,0.7) 20%, rgba(10,10,10,0.95) 100%);
    padding: 30px 20px 30px;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    backdrop-filter: blur(15px);
  }

  .controls {
    display: flex;
    gap: 16px;
    align-items: center;
  }

  .control-btn {
    width: 56px;
    height: 56px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.08);
    border: 2px solid rgba(255, 255, 255, 0.15);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    color: rgba(255, 255, 255, 0.8);
    font-size: 24px;
    position: relative;
  }

  .control-btn:hover {
    background: rgba(255, 255, 255, 0.15);
    border-color: rgba(255, 255, 255, 0.3);
    transform: translateY(-2px);
    color: #fff;
  }

  .control-btn:active {
    transform: translateY(0);
  }

  .control-btn.active {
    background: rgba(99, 102, 241, 0.25);
    border-color: rgba(99, 102, 241, 0.7);
    color: #6366F1;
  }

  .control-btn.muted {
    color: #EF4444;
    border-color: rgba(239, 68, 68, 0.4);
    background: rgba(239, 68, 68, 0.1);
  }

  .main-action-btn {
    width: 72px;
    height: 72px;
    font-size: 32px;
    background: rgba(255, 255, 255, 0.12);
    border: 3px solid rgba(255, 255, 255, 0.25);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  }

  .main-action-btn:hover {
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 6px 30px rgba(99, 102, 241, 0.4);
  }

  .main-action-btn.active {
    background: rgba(16, 185, 129, 0.25);
    border-color: rgba(16, 185, 129, 0.7);
    color: #10B981;
    animation: mainPulse 1.5s ease-in-out infinite;
  }

  @keyframes mainPulse {
    0%, 100% { box-shadow: 0 4px 20px rgba(16, 185, 129, 0.5); }
    50% { box-shadow: 0 8px 40px rgba(16, 185, 129, 0.9); }
  }

  .settings-panel {
    position: fixed;
    bottom: 120px;
    right: 20px;
    background: rgba(10, 10, 10, 0.95);
    border: 2px solid rgba(255, 255, 255, 0.1);
    border-radius: 20px;
    padding: 24px;
    display: none;
    flex-direction: column;
    gap: 20px;
    min-width: 320px;
    max-width: 90vw;
    backdrop-filter: blur(20px);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    max-height: 70vh;
    overflow-y: auto;
  }

  .settings-panel.active {
    display: flex;
    animation: slideUp 0.3s ease-out;
  }

  @keyframes slideUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .settings-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }

  .settings-title {
    color: rgba(255, 255, 255, 0.9);
    font-size: 18px;
    font-weight: 700;
  }

  .close-settings {
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.5);
    font-size: 24px;
    cursor: pointer;
    padding: 0;
    display: flex;
    align-items: center;
    transition: color 0.2s;
  }

  .close-settings:hover {
    color: rgba(255, 255, 255, 0.9);
  }

  .setting-section {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .section-title {
    color: rgba(255, 255, 255, 0.6);
    font-size: 12px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .setting-item {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .setting-label {
    color: rgba(255, 255, 255, 0.8);
    font-size: 14px;
    font-weight: 500;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .setting-value {
    color: rgba(99, 102, 241, 0.9);
    font-size: 13px;
    font-weight: 600;
  }

  .setting-input {
    background: rgba(255, 255, 255, 0.05);
    border: 1.5px solid rgba(255, 255, 255, 0.15);
    border-radius: 10px;
    padding: 12px 14px;
    color: #fff;
    font-size: 14px;
    transition: all 0.2s;
  }

  .setting-input:focus {
    outline: none;
    border-color: rgba(99, 102, 241, 0.6);
    background: rgba(255, 255, 255, 0.08);
  }

  .setting-select {
    background: rgba(255, 255, 255, 0.05);
    border: 1.5px solid rgba(255, 255, 255, 0.15);
    border-radius: 10px;
    padding: 12px 14px;
    color: #fff;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .setting-select:focus {
    outline: none;
    border-color: rgba(99, 102, 241, 0.6);
    background: rgba(255, 255, 255, 0.08);
  }

  .toggle-switch {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .switch {
    position: relative;
    width: 52px;
    height: 28px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 14px;
    cursor: pointer;
    transition: background 0.3s;
    border: 2px solid rgba(255, 255, 255, 0.15);
  }

  .switch.active {
    background: rgba(99, 102, 241, 0.3);
    border-color: rgba(99, 102, 241, 0.6);
  }

  .switch-thumb {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 20px;
    height: 20px;
    background: white;
    border-radius: 50%;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }

  .switch.active .switch-thumb {
    transform: translateX(24px);
  }

  .toggle-label {
    color: rgba(255, 255, 255, 0.7);
    font-size: 14px;
  }

  .action-btn {
    background: rgba(255, 255, 255, 0.08);
    border: 1.5px solid rgba(255, 255, 255, 0.15);
    border-radius: 10px;
    padding: 12px 16px;
    color: rgba(255, 255, 255, 0.8);
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }

  .action-btn:hover {
    background: rgba(255, 255, 255, 0.15);
    border-color: rgba(255, 255, 255, 0.3);
    transform: translateY(-1px);
  }

  .action-btn:active {
    transform: translateY(0);
  }

  .action-btn.danger {
    color: #EF4444;
    border-color: rgba(239, 68, 68, 0.3);
    background: rgba(239, 68, 68, 0.1);
  }

  .action-btn.danger:hover {
    border-color: #EF4444;
    background: rgba(239, 68, 68, 0.2);
  }

  /* Scrollbar styling */
  ::-webkit-scrollbar {
    width: 8px;
  }

  ::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 4px;
  }

  ::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.3);
  }

  @media (max-width: 640px) {
    .ghost {
      width: 200px;
      height: 250px;
    }

    .status-icon {
      width: 56px;
      height: 56px;
      font-size: 24px;
    }

    .status-text {
      font-size: 18px;
    }

    .status-subtitle {
      font-size: 13px;
    }

    .controls {
      gap: 12px;
    }

    .control-btn {
      width: 52px;
      height: 52px;
      font-size: 22px;
    }

    .main-action-btn {
      width: 64px;
      height: 64px;
      font-size: 28px;
    }
  }
</style>
</head>
<body>
  <div class="ghost-container">
    <div class="ghost idle" id="ghost">
      <div class="ghost-body">
        <div class="gradient"></div>
        <div class="eye left"></div>
        <div class="eye right"></div>
      </div>
      <div class="status-icon" id="statusIcon">
        <ion-icon name="mic-outline"></ion-icon>
      </div>
    </div>
    
    <div class="status-text">
      <div id="statusText">Ready to assist</div>
      <div class="status-subtitle" id="statusSubtitle">Tap the microphone to start</div>
    </div>
  </div>

  <div class="calling-ui">
    <div class="controls">
      <button class="control-btn" id="muteBtn" title="Mute">
        <ion-icon name="mic-outline"></ion-icon>
      </button>
      
      <button class="control-btn main-action-btn" id="talkBtn" title="Push to Talk">
        <ion-icon name="mic-outline"></ion-icon>
      </button>
      
      <button class="control-btn" id="settingsBtn" title="Settings">
        <ion-icon name="settings-outline"></ion-icon>
      </button>
    </div>
  </div>

  <div class="settings-panel" id="settingsPanel">
    <div class="settings-header">
      <div class="settings-title">Settings</div>
      <button class="close-settings" id="closeSettings">
        <ion-icon name="close-outline"></ion-icon>
      </button>
    </div>

    <div class="setting-section">
      <div class="section-title">Wake Word</div>
      <div class="setting-item">
        <div class="toggle-switch">
          <div class="switch" id="wakeWordToggle">
            <div class="switch-thumb"></div>
          </div>
          <span class="toggle-label">Enable wake word</span>
        </div>
      </div>
      <div class="setting-item" id="wakeWordInputContainer" style="display: none;">
        <input type="text" class="setting-input" id="wakeWordInput" placeholder="e.g., Hey Ghost" value="hey ghost">
      </div>
    </div>

    <div class="setting-section">
      <div class="section-title">Behavior</div>
      <div class="setting-item">
        <div class="toggle-switch">
          <div class="switch active" id="interruptToggle">
            <div class="switch-thumb"></div>
          </div>
          <span class="toggle-label">Interrupt when speaking</span>
        </div>
      </div>
    </div>

    <div class="setting-section">
      <div class="section-title">Voice</div>
      <div class="setting-item">
        <select class="setting-select" id="voiceSelect">
          <option value="">Default Voice</option>
        </select>
      </div>

      <div class="setting-item">
        <label class="setting-label">
          <span>Speed</span>
          <span class="setting-value" id="speedValue">1.0x</span>
        </label>
        <input type="range" class="setting-input" id="voiceSpeed" min="0.5" max="2" step="0.1" value="1">
      </div>

      <div class="setting-item">
        <label class="setting-label">
          <span>Volume</span>
          <span class="setting-value" id="volumeValue">100%</span>
        </label>
        <input type="range" class="setting-input" id="voiceVolume" min="0" max="1" step="0.1" value="1">
      </div>
    </div>

    <div class="setting-section">
      <button class="action-btn" id="testVoiceBtn">
        <ion-icon name="play-outline"></ion-icon>
        Test Voice
      </button>
    </div>
  </div>

<script>
  const eyes = document.querySelectorAll('.eye');
  let targetX = 0, targetY = 0;
  let currentX = 0, currentY = 0;
  const maxOffset = 8;
  const speed = 0.08;

  document.addEventListener('mousemove', e => {
    const rect = document.querySelector('.ghost').getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    const deltaX = (e.clientX - centerX) * 0.08;
    const deltaY = (e.clientY - centerY) * 0.08;
    targetX = Math.max(-maxOffset, Math.min(maxOffset, deltaX));
    targetY = Math.max(-maxOffset, Math.min(maxOffset, deltaY));
  });

  function animateEyes() {
    currentX += (targetX - currentX) * speed;
    currentY += (targetY - currentY) * speed;

    eyes.forEach(eye => {
      const baseX = eye.classList.contains('left') ? 80 : 150;
      const baseY = 120;
      eye.style.left = `${baseX + currentX}px`;
      eye.style.top = `${baseY + currentY}px`;
    });

    requestAnimationFrame(animateEyes);
  }

  animateEyes();

  const GROQ_API_KEY = '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';
  
  const talkBtn = document.getElementById('talkBtn');
  const muteBtn = document.getElementById('muteBtn');
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsPanel = document.getElementById('settingsPanel');
  const closeSettings = document.getElementById('closeSettings');
  const ghost = document.getElementById('ghost');
  const statusIcon = document.getElementById('statusIcon');
  const statusText = document.getElementById('statusText');
  const statusSubtitle = document.getElementById('statusSubtitle');
  const wakeWordInput = document.getElementById('wakeWordInput');
  const wakeWordToggle = document.getElementById('wakeWordToggle');
  const wakeWordInputContainer = document.getElementById('wakeWordInputContainer');
  const interruptToggle = document.getElementById('interruptToggle');
  const voiceSelect = document.getElementById('voiceSelect');
  const voiceSpeed = document.getElementById('voiceSpeed');
  const voiceVolume = document.getElementById('voiceVolume');
  const speedValue = document.getElementById('speedValue');
  const volumeValue = document.getElementById('volumeValue');
  const testVoiceBtn = document.getElementById('testVoiceBtn');

  let isListening = false;
  let isSpeaking = false;
  let isMuted = false;
  let interruptMode = true;
  let wakeWord = 'hey ghost';
  let wakeWordEnabled = false;
  let recognition = null;
  let synthesis = window.speechSynthesis;
  let currentUtterance = null;
  let conversationHistory = [];
  let waitingForWakeWord = false;
  let selectedVoice = null;
  let isProcessing = false;

  function initializeSpeechRecognition() {
    if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
      updateStatus('idle', 'Not supported', 'Please use Chrome or Edge');
      return false;
    }

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    recognition = new SpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.lang = 'en-US';

    recognition.onresult = (event) => {
      const last = event.results.length - 1;
      const text = event.results[last][0].transcript.toLowerCase().trim();
      const isFinal = event.results[last].isFinal;

      if (wakeWordEnabled && waitingForWakeWord && isListening) {
        if (text.includes(wakeWord.toLowerCase())) {
          waitingForWakeWord = false;
          updateStatus('listening', 'Listening', 'Speak your question');
          
          const afterWakeWord = text.split(wakeWord.toLowerCase())[1]?.trim();
          if (afterWakeWord && isFinal) {
            processUserInput(afterWakeWord);
          }
        }
      } else if ((!wakeWordEnabled || !waitingForWakeWord) && isFinal && text.trim()) {
        if (interruptMode && isSpeaking) {
          stopSpeaking();
        }
        processUserInput(text);
      }
    };

    recognition.onerror = (event) => {
      if (event.error === 'not-allowed') {
        updateStatus('idle', 'Microphone blocked', 'Please allow access');
      }
    };

    recognition.onend = () => {
      if (isListening && !isMuted) {
        try {
          recognition.start();
        } catch (e) {}
      }
    };

    return true;
  }

  async function processUserInput(text) {
    if (!text || text.trim() === '' || isProcessing) return;
    
    isProcessing = true;
    updateStatus('thinking', 'Thinking', 'Processing your request...');
    
    try {
      const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${GROQ_API_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: 'llama-3.3-70b-versatile',
          messages: [
            {
              role: 'system',
              content: 'You are Ghost, a friendly and helpful AI assistant. Keep responses concise and conversational, ideally 1-3 sentences unless more detail is needed.'
            },
            ...conversationHistory.slice(-6),
            {
              role: 'user',
              content: text
            }
          ],
          temperature: 0.8,
          max_tokens: 150
        })
      });

      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }

      const data = await response.json();
      const aiResponse = data.choices[0].message.content;
      
      conversationHistory.push(
        { role: 'user', content: text },
        { role: 'assistant', content: aiResponse }
      );

      if (conversationHistory.length > 16) {
        conversationHistory = conversationHistory.slice(-16);
      }

      speak(aiResponse);
      
    } catch (error) {
      speak('Sorry, I encountered an error. Please try again.');
      updateStatus('idle', 'Error occurred', 'Please try again');
      setTimeout(() => {
        if (isListening) {
          updateStatus('listening', 'Listening', wakeWordEnabled ? `Say "${wakeWord}"` : 'Speak now');
        } else {
          updateStatus('idle', 'Ready', 'Tap to speak');
        }
      }, 2000);
    } finally {
      isProcessing = false;
    }
  }

  function speak(text) {
    stopSpeaking();
    
    currentUtterance = new SpeechSynthesisUtterance(text);
    currentUtterance.rate = parseFloat(voiceSpeed.value);
    currentUtterance.volume = parseFloat(voiceVolume.value);
    
    if (selectedVoice) {
      currentUtterance.voice = selectedVoice;
    }

    currentUtterance.onstart = () => {
      isSpeaking = true;
      updateStatus('speaking', 'Speaking', 'AI is responding...');
    };

    currentUtterance.onend = () => {
      isSpeaking = false;
      
      if (isListening) {
        if (wakeWordEnabled) {
          waitingForWakeWord = true;
          updateStatus('listening', 'Listening', `Say "${wakeWord}"`);
        } else {
          updateStatus('listening', 'Listening', 'Speak now');
        }
      } else {
        updateStatus('idle', 'Ready', 'Tap to speak');
      }
    };

    currentUtterance.onerror = () => {
      isSpeaking = false;
      updateStatus('idle', 'Speech error', 'Try again');
    };

    synthesis.speak(currentUtterance);
  }

  function stopSpeaking() {
    if (synthesis.speaking) {
      synthesis.cancel();
      isSpeaking = false;
    }
  }

  function updateStatus(state, text, subtitle = '') {
    statusText.textContent = text;
    statusSubtitle.textContent = subtitle;
    ghost.className = `ghost ${state}`;
    
    const iconMap = {
      'idle': 'mic-outline',
      'listening': 'radio-outline',
      'speaking': 'volume-high-outline',
      'thinking': 'hourglass-outline'
    };
    
    statusIcon.querySelector('ion-icon').setAttribute('name', iconMap[state] || 'mic-outline');
  }

  talkBtn.addEventListener('click', () => {
    if (!recognition) {
      alert('Speech recognition not supported. Please use Chrome or Edge.');
      return;
    }

    isListening = !isListening;
    
    if (isListening) {
      if (!isMuted) {
        try {
          recognition.start();
        } catch (e) {}
        talkBtn.classList.add('active');
        waitingForWakeWord = wakeWordEnabled;
        updateStatus('listening', 'Listening', wakeWordEnabled ? `Say "${wakeWord}"` : 'Speak now');
      }
    } else {
      recognition.stop();
      talkBtn.classList.remove('active');
      waitingForWakeWord = false;
      updateStatus('idle', 'Ready', 'Tap to speak');
    }
  });

  muteBtn.addEventListener('click', () => {
    isMuted = !isMuted;
    
    if (isMuted) {
      muteBtn.classList.add('muted');
      muteBtn.querySelector('ion-icon').setAttribute('name', 'mic-off-outline');
      if (isListening) {
        recognition.stop();
      }
      updateStatus('idle', 'Muted', 'Unmute to continue');
    } else {
      muteBtn.classList.remove('muted');
      muteBtn.querySelector('ion-icon').setAttribute('name', 'mic-outline');
      if (isListening) {
        try {
          recognition.start();
        } catch (e) {}
        updateStatus('listening', 'Listening', wakeWordEnabled ? `Say "${wakeWord}"` : 'Speak now');
      }
    }
  });

  settingsBtn.addEventListener('click', () => {
    settingsPanel.classList.toggle('active');
    settingsBtn.classList.toggle('active');
  });

  closeSettings.addEventListener('click', () => {
    settingsPanel.classList.remove('active');
    settingsBtn.classList.remove('active');
  });

  interruptToggle.addEventListener('click', () => {
    interruptMode = !interruptMode;
    interruptToggle.classList.toggle('active', interruptMode);
  });

  wakeWordToggle.addEventListener('click', () => {
    wakeWordEnabled = !wakeWordEnabled;
    wakeWordToggle.classList.toggle('active', wakeWordEnabled);
    wakeWordInputContainer.style.display = wakeWordEnabled ? 'flex' : 'none';
    
    if (isListening) {
      waitingForWakeWord = wakeWordEnabled;
      updateStatus('listening', 'Listening', wakeWordEnabled ? `Say "${wakeWord}"` : 'Speak now');
    }
  });

  wakeWordInput.addEventListener('change', (e) => {
    wakeWord = e.target.value.toLowerCase().trim();
    if (isListening && waitingForWakeWord && wakeWordEnabled) {
      updateStatus('listening', 'Listening', `Say "${wakeWord}"`);
    }
  });

  voiceSpeed.addEventListener('input', (e) => {
    speedValue.textContent = `${parseFloat(e.target.value).toFixed(1)}x`;
  });

  voiceVolume.addEventListener('input', (e) => {
    volumeValue.textContent = `${Math.round(parseFloat(e.target.value) * 100)}%`;
  });

  testVoiceBtn.addEventListener('click', () => {
    speak('Hello! I am Ghost, your AI assistant. How can I help you today?');
  });

  function loadVoices() {
    const voices = synthesis.getVoices();
    voiceSelect.innerHTML = '<option value="">Default Voice</option>';
    
    voices.forEach(voice => {
      const option = document.createElement('option');
      option.value = voice.name;
      option.textContent = `${voice.name} (${voice.lang})`;
      voiceSelect.appendChild(option);
    });

    const preferredVoice = voices.find(v => 
      v.name.includes('Google') || 
      v.name.includes('Natural') || 
      v.name.includes('Enhanced')
    );
    
    if (preferredVoice) {
      selectedVoice = preferredVoice;
      voiceSelect.value = preferredVoice.name;
    }
  }

  voiceSelect.addEventListener('change', (e) => {
    const voices = synthesis.getVoices();
    selectedVoice = voices.find(v => v.name === e.target.value) || null;
  });

  if (synthesis.onvoiceschanged !== undefined) {
    synthesis.onvoiceschanged = loadVoices;
  }

  window.addEventListener('load', () => {
    const initialized = initializeSpeechRecognition();
    if (initialized) {
      loadVoices();
      updateStatus('idle', 'Ready to assist', 'Tap the microphone to start');
    }
  });
</script>
</body>
</html>
